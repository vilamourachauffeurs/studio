/**
 * @file Firestore Security Rules for Chauffeur Pro
 * @version 2
 *
 * @Core Philosophy:
 * This ruleset enforces a mixed security model, balancing open access for certain collections with
 * strict ownership or role-based access for others. Public information such as client, driver, partner,
 * and operator details are generally readable, while user profiles and bookings are protected.
 *
 * @Data Structure:
 * The Firestore database consists of several top-level collections: `users`, `bookings`, `drivers`, `clients`,
 * `partners`, and `operators`. Each collection contains documents representing entities of the corresponding type.
 * - `/users/{userId}`: Stores public user profiles.
 * - `/bookings/{bookingId}`: Contains booking information.
 * - `/drivers/{driverId}`: Stores driver information.
 * - `/clients/{clientId}`: Stores client information.
 * - `/partners/{partnerId}`: Stores partner information.
 * - `/operators/{operatorId}`: Stores operator information.
 *
 * @Key Security Decisions:
 * - User listing is disallowed.
 * - Public read access is granted to `clients`, `drivers`, `partners`, and `operators` collections.
 * - Bookings are secured using a combination of ownership and role-based access, with the `createdById` field
 *   controlling who can modify them.
 * - User profiles are strictly owner-accessible.
 *
 * @Denormalization for Authorization:
 * The rules leverage the `createdById` field on the `bookings` document to efficiently determine the creator of the booking.
 * This avoids the need for complex queries or additional reads to determine ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Grants owner-only access to user profiles.
     * @path /users/{userId}
     * @allow (create) User with ID 'user_abc' can create their profile.
     *   `request.auth.uid == 'user_abc'`
     *   `request.resource.data.id == 'user_abc'`
     * @allow (get, update, delete) User with ID 'user_abc' can read/update/delete their profile.
     *   `request.auth.uid == 'user_abc'`
     * @deny (create) User with ID 'user_abc' cannot create profile for 'user_def'.
     *   `request.auth.uid == 'user_abc'`
     *   `request.resource.data.id == 'user_def'`
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      //isOwner function is called here to check if the user is the owner of the document or not
      allow get: if isOwner(userId);
      allow list: if false; // User listing is disallowed.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages access control for bookings, allowing public read access but restricting writes to the booking creator.
     * @path /bookings/{bookingId}
     * @allow (get, list) Anyone can read bookings.
     * @allow (create) User with ID 'user_abc' can create a booking with createdById 'user_abc'.
     *   `request.auth.uid == 'user_abc'`
     *   `request.resource.data.createdById == 'user_abc'`
     * @allow (update, delete) User with ID 'user_abc' can update/delete a booking they created.
     *   `request.auth.uid == 'user_abc'`
     *   `resource.data.createdById == 'user_abc'`
     * @deny (create) User with ID 'user_abc' cannot create a booking with createdById 'user_def'.
     *   `request.auth.uid == 'user_abc'`
     *   `request.resource.data.createdById == 'user_def'`
     * @deny (update, delete) User with ID 'user_abc' cannot update/delete a booking created by 'user_def'.
     *   `request.auth.uid == 'user_abc'`
     *   `resource.data.createdById == 'user_def'`
     * @principle Enforces document ownership for writes, while allowing public reads.
     */
    match /bookings/{bookingId} {
      //isBookingOwner function is called here to check if the user is the owner of the booking document or not
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.createdById == request.auth.uid;
      allow update: if isSignedIn() && isExistingBookingOwner(resource.data.createdById);
      allow delete: if isSignedIn() && isExistingBookingOwner(resource.data.createdById);
    }

    /**
     * @description Allows public read access to drivers.
     * @path /drivers/{driverId}
     * @allow (get, list) Anyone can read drivers.
     * @allow (create) No one can create drivers. // TODO: Determine who should be able to create drivers.
     * @allow (update) No one can update drivers. // TODO: Determine who should be able to update drivers.
     * @allow (delete) No one can delete drivers. // TODO: Determine who should be able to delete drivers.
     */
    match /drivers/{driverId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to clients.
     * @path /clients/{clientId}
     * @allow (get, list) Anyone can read clients.
     * @allow (create) No one can create clients. // TODO: Determine who should be able to create clients.
     * @allow (update) No one can update clients. // TODO: Determine who should be able to update clients.
     * @allow (delete) No one can delete clients. // TODO: Determine who should be able to delete clients.
     */
    match /clients/{clientId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to partners.
     * @path /partners/{partnerId}
     * @allow (get, list) Anyone can read partners.
     * @allow (create) No one can create partners. // TODO: Determine who should be able to create partners.
     * @allow (update) No one can update partners. // TODO: Determine who should be able to update partners.
     * @allow (delete) No one can delete partners. // TODO: Determine who should be able to delete partners.
     */
    match /partners/{partnerId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to operators.
     * @path /operators/{operatorId}
     * @allow (get, list) Anyone can read operators.
     * @allow (create) No one can create operators. // TODO: Determine who should be able to create operators.
     * @allow (update) No one can update operators. // TODO: Determine who should be able to update operators.
     * @allow (delete) No one can delete operators. // TODO: Determine who should be able to delete operators.
     */
    match /operators/{operatorId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isBookingOwner(createdById) {
      return request.auth.uid == createdById;
    }

    function isExistingBookingOwner(createdById) {
        return isBookingOwner(createdById) && resource != null;
    }
  }
}